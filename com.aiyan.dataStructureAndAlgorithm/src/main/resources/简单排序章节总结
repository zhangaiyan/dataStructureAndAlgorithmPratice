一、冒泡排序
1、算法思路：将最小的数据项放在数组的最开始，并将最大的数据项放在数组的最后。外层for循环的计数器out从数组的最后开始，每经过一次循环out-1，
此时下标大于out的数据项都已经是有序的了。变量out在每完成一次内部循环后，内部计数器in左移一位，从而使得算法不必去处理那些已经排好序的数据。
内存for循环计数器in从数组最开始算起，每完成一次内部循环in+1，当它等于out时结束一次循环。在内层for循环体中，数组下标为in和in+1的两个数据项比较，
若下标为n的数据项大于下标为n+1的数据项，则交换两个数据项。
2、不变性：在许多算法中，有些条件在算法执行时是不变的。冒泡排序中out右边的所有数据项都是有序的，在算法的整个运行过程中这个条件始终为真。
3、效率：比较和交换的次数都和N^2成正比。

二、选择排序
1、算法思路：外层循环用循环变量out，从数组开头开始向高位增长，内层循环用循环变量in，从out所指位置开始，同样是向右移位。在每一个in的新位置，
数据项a[in]和a[min]进行比较，若a[in]更小，则min被赋值为in的值。在内层循环的最后，min指向最小的数据项，然后交换out和min指向的数组的数据项。
2、不变性：下标小于或等于out的位置的数据项总是有序的。
3、效率：比较的次数和N^2成正比，交互次数同N成正比【在C或C++中，交换会使大量记录在内存中移动，使得交换时间相较于比较时间更为重要】
【Java只改变了对象引用的位置，实际对象位置并不会发生改变】

三、插入排序
1、算法思路：在外层的for循环中，out变量从1开始，向右移动，它标记了未排序部分最左端的数据。而在内存的while循环中，in变量从out变量开始，向左移动，
直到temp变量小于in所指的数组数据项，或者它已经不能再往左移为止。while循环的每一趟都向右移动了一个已排序的数据项。
2、不变性：在将temp位置的项插入后，比outer变量下标小的数据项都是局部有序的。
3、效率：比较次数和N^2成正比，复制次数和N^2成正比，但一次复制所用的时间为交互的1/3。
对于已经有序或基本有序的数组来说，插入排序要好很多，当数据有序的时候，while循环的条件总是假，所以它变成了外层循环中的一个简单语句，所以它变成外层循环中的
一个简单语句，执行N-1次，在这种情况下，算法运行只需要O(N)的时间。【通常会在快速排序结尾时使用插入排序】

四、三种算法共性：
1、比较两个数据项
2、交换两个数据项，或复制其中一项
3、时间复杂度都为O(N^2)
4、都可以"就地"完成排序，空间复杂度都为O(1)
